package org.lacitysan.landfill.tools.enumeration.gen.userpermission;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.lacitysan.landfill.server.persistence.enums.UserPermission;
import org.lacitysan.landfill.tools.enumeration.gen.userpermission.model.UserPermissionConstant;

/**
 * @author Alvin Quach
 */
public class UserPermissionGenApplication {

	/** The package of the generated enum. */
	private static final String PACKAGE = UserPermission.class.getPackage().getName();

	/** The name of the generated enum. */
	private static final String CLASS_NAME = UserPermission.class.getSimpleName();

	/** The base output path of the generate enum class. Set this to the <code>src/main/java</code> directory of the server project. */
	private static final String OUTPUT_BASE_PATH = "D:\\Eclipse Workspaces\\Landfill-eForms\\landfill-web-app\\server\\src\\main\\java";

	private static final String WORKSHEET_PATH = "D:\\Alvin\\Downloads\\User Roles.xlsx";

	public static void main(String[] args) {

		try {

			XSSFWorkbook workbook = new XSSFWorkbook(new File(WORKSHEET_PATH));
			XSSFSheet worksheet = workbook.getSheetAt(0);

			Set<UserPermissionConstant> userPermissionConstants = parse(worksheet);

			writeToFile(generateEnumClass(userPermissionConstants));

			workbook.close();

		} catch (InvalidFormatException | IOException e) {
			e.printStackTrace();
			return;
		} 

	}

	static Set<UserPermissionConstant> parse(XSSFSheet worksheet) {
		Set<UserPermissionConstant> result = new TreeSet<>();
		for (Row row : worksheet) {
			
			// Check if the row is an actual entry by checking if the first column is an ordinal.
			Cell ordinalCell = row.getCell(0);
			if (ordinalCell == null || row.getCell(0).getCellTypeEnum() != CellType.NUMERIC) {
				continue;
			}
			int ordinal = (int)ordinalCell.getNumericCellValue();

			// Parse cell 1 for enum constant name.
			Cell constantNameCell = row.getCell(1);
			if (constantNameCell == null) {
				continue;
			}
			String constantName = constantNameCell.toString().trim().toUpperCase().replaceAll(" ", "_");
			if (constantName.isEmpty()) {
				continue;
			}

			// Parse cell 2 for description.
			String description = row.getCell(2).toString().trim();

			// Parse cell 3 for category code.
			String category = row.getCell(3).toString().trim(); 

			// Parse cell 4 for category action.
			String categoryAction = row.getCell(4).toString().trim();

			// Parse cell 5 for additional comments.
			String comments = row.getCell(5).toString().trim();

			result.add(new UserPermissionConstant(ordinal, constantName, description, category, categoryAction, comments));

		}
		return result;
	}

	static String generateEnumClass(Collection<UserPermissionConstant> constants) {

		// Create new TreeMap to store Category constants and its original string in alphabetical order. 
		Map<String, String> categoryMap = new TreeMap<>();

		// Create new string builder with package declaration.
		StringBuilder sb = new StringBuilder("package " + PACKAGE + ";");

		// Imports
		sb.append("\n\nimport org.lacitysan.landfill.server.json.LandfillEnumDeserializer;")
		.append("\n\nimport com.fasterxml.jackson.annotation.JsonCreator;")

		// Javadoc comment for the generated enum.
		.append("\n\n/**")
		.append("\n").append(" * This file was automatically generated by 'user-permission-enum-gen'.")
		.append("\n").append(" * https://github.com/landfill-eforms/landfill-tools/tree/master/user-permission-enum-gen")
		.append("\n").append(" *")
		.append("\n").append(" * Data was parsed from the Excel sheet located at https://docs.google.com/spreadsheets/d/1qD6SvrIjW-FTFVWyO6cMKr4DaV_laGqgzV4Im_wNMWc")
		.append("\n").append(" */")

		// Enum delcaration
		.append("\n").append("public enum " + CLASS_NAME + " {\n");

		// Enum constants
		int i = 1;
		for (UserPermissionConstant constant : constants) {

			// Javadoc comment for the enum constant.
			sb.append("\n\t")
			.append("/** ")
			.append(constant.getDescription())
			.append(constant.getComments().isEmpty() ? "" : " <i>" + constant.getComments() + "</i>")
			.append(" */");

			// Enum constant declaration
			sb.append("\n\t")
			.append(constant.getConstantName())

			// Constructor call
			.append(" (\"")
			.append(constant.getDescription())
			.append("\", ");

			// Calculate the category, if exists.
			String category = constant.getCategory().toUpperCase().replaceAll(" ", "_");
			if (!category.isEmpty()) {

				// Continue constructor call
				categoryMap.put(category, constant.getCategory());
				sb.append("Category.")
				.append(category)
				.append(", \"")
				.append(constant.getCategoryAction())
				.append("\", ");
			}

			// Continue constructor call
			sb.append("\"")
			.append(constant.getDescription())
			.append("\")")
			.append(i++ == constants.size() ? ";" : ",\n");

		}
		
		// Private fields
		sb.append("\n")
		.append("\n\t").append("private String name;")
		.append("\n\t").append("private String category;")
		.append("\n\t").append("private String categoryAction;")
		.append("\n\t").append("private String description;")
		
		// Constructors
		.append("\n\n\t").append("private " + CLASS_NAME + "(String name, String description) {")
		.append("\n\t\t").append("this.name = name;")
		.append("\n\t\t").append("this.description = description;")
		.append("\n\t}")
		.append("\n\n\t").append("private " + CLASS_NAME + "(String name, String category, String categoryAction, String description) {")
		.append("\n\t\t").append("this.name = name;")
		.append("\n\t\t").append("this.category = category;")
		.append("\n\t\t").append("this.categoryAction = categoryAction;")
		.append("\n\t\t").append("this.description = description;")
		.append("\n\t}")

		// Getters
		.append("\n\n\t").append("public String getName() {")
		.append("\n\t\t").append("return name;")
		.append("\n\t}")
		.append("\n\n\t").append("public String getCategory() {")
		.append("\n\t\t").append("return category;")
		.append("\n\t}")
		.append("\n\n\t").append("public String getCategoryAction() {")
		.append("\n\t\t").append("return categoryAction;")
		.append("\n\t}")
		.append("\n\n\t").append("public String getDescription() {")
		.append("\n\t\t").append("return description;")
		.append("\n\t}")
		
		// Deserializer
		.append("\n\n\t").append("@JsonCreator")
		.append("\n\t").append("public static " + CLASS_NAME + " deserialize(Object object) {")
		.append("\n\t\t").append("return LandfillEnumDeserializer.deserialize(" + CLASS_NAME + ".class, object);")
		.append("\n\t}")
		
		// Category constants
		.append("\n\n\t").append("private static class Category {");
		for (String category : categoryMap.keySet()) {
			sb.append("\n\t\t")
			.append("protected final static String ")
			.append(category)
			.append(" = \"")
			.append(categoryMap.get(category))
			.append("\";");
		}
		sb.append("\n\t}")
		
		// Closing brackets
		.append("\n\n}");
		
		return sb.toString();

	}

	static void writeToFile(String contents) {
		String relativePath = PACKAGE.replace(".", File.separator);
		String filePath = OUTPUT_BASE_PATH + File.separator + relativePath;
		System.out.println("OUTPUT PATH: " + filePath + "\n");
		new File(filePath).mkdirs();
		try (BufferedWriter bw = new BufferedWriter(new FileWriter(filePath + File.separator + CLASS_NAME + ".java", false))) {
			bw.write(contents);
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println(contents);
	}

}

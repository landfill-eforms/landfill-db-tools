package org.lacitysan.landfill.tools.enumeration.gen;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.Set;
import java.util.TreeSet;

import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.lacitysan.landfill.server.model.MonitoringPointType;
import org.lacitysan.landfill.server.model.Site;
import org.lacitysan.landfill.tools.enumeration.gen.model.MonitoringPointConstant;

public class MonitoringPointGenApplication {
	
	/** The package of the generated enum. This is set to the same package as the Site enum. */
	private static final String PACKAGE = Site.class.getPackage().getName();
	
	/** The base output path of the generate enum class. Set this to the <code>src/main/java</code> directory of the server project. */
	private static final String OUTPUT_BASE_PATH = "D:\\Eclipse Workspaces\\Landfill-eForms\\landfill-web-app\\server\\src\\main\\java";
	
	private static final String WORKSHEET_PATH = "D:\\Alvin\\Downloads\\Site and type list.xlsx";
	
	public static void main(String[] args) {

		try {
			
			XSSFWorkbook workbook = new XSSFWorkbook(new File(WORKSHEET_PATH));
			XSSFSheet worksheet = workbook.getSheetAt(0);
			
			Set<MonitoringPointConstant> monitoringPointConstants = parse(worksheet);
			
			writeToFile(generateEnumClass(monitoringPointConstants));
			
			workbook.close();

		} catch (InvalidFormatException | IOException e) {
			e.printStackTrace();
			return;
		} 

	}
	
	static Set<MonitoringPointConstant> parse(XSSFSheet worksheet) {
		Set<MonitoringPointConstant> result = new TreeSet<>();
		for (Row row : worksheet) {
			
			// Parse cell 0 for the site.
			Site site = MonitoringPointGenUtils.getSiteByName(row.getCell(0).getStringCellValue());
			if (site == null) {
				continue;
			}
			
			// Parse cell 1 for the monitorig point type.
			MonitoringPointType type = MonitoringPointGenUtils.getMonitoringPointTypeByName(row.getCell(1).getStringCellValue());
			if (type == null) {
				continue;
			}
			
			// Parse cell 2 for monitoring point name (ID).
			Cell nameCell = row.getCell(2);
			String name = nameCell.toString();
			
			// If the monitoring point name is a number, need to manually convert it to an integer; the toString() method results in a float.
			if (nameCell.getCellTypeEnum() == CellType.NUMERIC) {
				name = String.valueOf((int)nameCell.getNumericCellValue());
			}
			
			// Combine site short name, type name, and monitoring point name (ID) to create the enum constant name.
			String constantName = site.getShortName() + "_" + type.name() + "_" + name.replaceAll("[- ]+", "_").replaceAll("\\+", " ").toUpperCase();
			
			result.add(new MonitoringPointConstant(constantName, name, site, type));
			
		}
		return result;
	}
	
	static String generateEnumClass(Collection<MonitoringPointConstant> constants) {
		
		// Create new string builder with package declaration.
		StringBuilder sb = new StringBuilder("package " + PACKAGE + ";");
		
		// Javadoc comment for the generated enum.
		sb.append("\n\n/**")
		.append("\n").append(" * This file was automatically generated by 'monitoringpoint-enum-gen'.")
		.append("\n").append(" * https://github.com/landfill-eforms/landfill-tools/tree/master/monitoringpoint-enum-gen")
		.append("\n").append(" *")
		.append("\n").append(" * Data was parsed from the Excel sheet located at https://drive.google.com/file/d/0B59D4SQOmsslV1lLNFFKMVhQdTg/view?usp=sharing")
		.append("\n").append(" */")
		
		// Enum delcaration
		.append("\n").append("public enum MonitoringPoint {\n");

		// Enum constants
		int i = 1;
		for (MonitoringPointConstant constant : constants) {
			sb.append("\n\t")
			.append(constant.getConstantName());
			
			// Calculate the amount of tabs to insert between constant name and constructor call.
			int tabSize = 4;
			int tabsRequired = 8;
			int tabCount = (tabsRequired * tabSize - constant.getConstantName().length()) / tabSize + ((tabsRequired * tabSize - constant.getConstantName().length()) % tabSize > 0 ? 1 : 0);
			
			// Insert tabs
			for (int j = 0; j < tabCount; j++) {
				sb.append("\t");
			}
			
			// Constructor call
			sb.append("(\"")
			.append(constant.getName())
			.append("\", ")
			.append("Site.")
			.append(constant.getSite().name())
			.append(", ")
			.append("MonitoringPointType.")
			.append(constant.getType().name())
			.append(")")
			.append(i++ == constants.size() ? ";" : ",");
		}
		
		// Private fields
		sb.append("\n")
		.append("\n\t").append("private String name;")
		.append("\n\t").append("private Site site;")
		.append("\n\t").append("private MonitoringPointType type;")
		
		// Constructor
		.append("\n\n\t").append("private MonitoringPoint(String name, Site site, MonitoringPointType type) {")
		.append("\n\t\t").append("this.name = name;")
		.append("\n\t\t").append("this.site = site;")
		.append("\n\t\t").append("this.type = type;")
		.append("\n\t}")
		
		// Getters
		.append("\n\n\t").append("public String getName() {")
		.append("\n\t\t").append("return name;")
		.append("\n\t}")
		.append("\n\t").append("public Site getSite() {")
		.append("\n\t\t").append("return site;")
		.append("\n\t}")
		.append("\n\t").append("public MonitoringPointType getType() {")
		.append("\n\t\t").append("return type;")
		.append("\n\t}")
		
		// Closing brackets
		.append("\n\n}");
		
		return sb.toString();
		
	}
	
	static void writeToFile(String contents) {
		String relativePath = PACKAGE.replace(".", File.separator);
		String filePath = OUTPUT_BASE_PATH + File.separator + relativePath;
		System.out.println("OUTPUT PATH: " + filePath + "\n");
		new File(filePath).mkdirs();
		try (BufferedWriter bw = new BufferedWriter(new FileWriter(filePath + File.separator + "MonitoringPoint.java", false))) {
			bw.write(contents);
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println(contents);
	}

}
